{"uid":"a37420d10efd5a06","name":"Verify negative cases for the HMNFD /subscriptions API","fullName":"api.1-non-disruptive.test_subscriptions_negative.tavern#Verify negative cases for the HMNFD /subscriptions API","historyId":"e0735a7d07c9231aa06e45d7d71f9c36","time":{"start":1689614415589,"stop":1689614415589,"duration":0},"status":"failed","statusMessage":"FileNotFoundError: [Errno 2] No such file or directory: 'src/app/tavern_global_config_ct_test_environment.yaml'","statusTrace":"cls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_runtest_hook.<locals>.<lambda> at 0x7f353124f820>\nwhen = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n>           result: Optional[TResult] = func()\n\n/usr/lib/python3.9/site-packages/_pytest/runner.py:338: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )\n\n/usr/lib/python3.9/site-packages/_pytest/runner.py:259: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_HookCaller 'pytest_runtest_call'>\nkwargs = {'item': <YamlItem Verify negative cases for the HMNFD /subscriptions API>}\nfirstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\n\n/usr/lib/python3.9/site-packages/pluggy/_hooks.py:433: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_pytest.config.PytestPluginManager object at 0x7f3533087820>\nhook_name = 'pytest_runtest_call'\nmethods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.9/site-packages/_pytest/runner...in=<module '_pytest.unraisableexception' from '/usr/lib/python3.9/site-packages/_pytest/unraisableexception.py'>>, ...]\nkwargs = {'item': <YamlItem Verify negative cases for the HMNFD /subscriptions API>}\nfirstresult = False\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n\n/usr/lib/python3.9/site-packages/pluggy/_manager.py:112: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.9/site-packages/_pytest/runner...in=<module '_pytest.unraisableexception' from '/usr/lib/python3.9/site-packages/_pytest/unraisableexception.py'>>, ...]\ncaller_kwargs = {'item': <YamlItem Verify negative cases for the HMNFD /subscriptions API>}\nfirstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, _Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen,))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no _Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n    \n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n    \n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: _Result[object | list[object]] = _Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = _Result(results, exception)\n    \n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                        except StopIteration:\n                            pass\n                    else:\n                        try:\n                            if outcome._exception is not None:\n                                teardown.throw(outcome._exception)\n                            else:\n                                teardown.send(outcome._result)\n                            # Following is unreachable for a well behaved hook wrapper.\n                            # Try to force finalizers otherwise postponed till GC action.\n                            # Note: close() may raise if generator handles GeneratorExit.\n                            teardown.close()\n                        except StopIteration as si:\n                            outcome.force_result(si.value)\n                            continue\n                        except BaseException as e:\n                            outcome.force_exception(e)\n                            continue\n                        _raise_wrapfail(teardown, \"has second yield\")\n    \n>               return outcome.get_result()\n\n/usr/lib/python3.9/site-packages/pluggy/_callers.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pluggy._result._Result object at 0x7f35311675e0>\n\n    def get_result(self) -> _T:\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        if exc is None:\n            return cast(_T, self._result)\n        else:\n>           raise exc.with_traceback(exc.__traceback__)\n\n/usr/lib/python3.9/site-packages/pluggy/_result.py:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.9/site-packages/_pytest/runner...in=<module '_pytest.unraisableexception' from '/usr/lib/python3.9/site-packages/_pytest/unraisableexception.py'>>, ...]\ncaller_kwargs = {'item': <YamlItem Verify negative cases for the HMNFD /subscriptions API>}\nfirstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, _Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen,))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n\n/usr/lib/python3.9/site-packages/pluggy/_callers.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = <YamlItem Verify negative cases for the HMNFD /subscriptions API>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n        except AttributeError:\n            pass\n        try:\n            item.runtest()\n        except Exception as e:\n            # Store trace info to allow postmortem debugging\n            sys.last_type = type(e)\n            sys.last_value = e\n            assert e.__traceback__ is not None\n            # Skip *this* frame\n            sys.last_traceback = e.__traceback__.tb_next\n>           raise e\n\n/usr/lib/python3.9/site-packages/_pytest/runner.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = <YamlItem Verify negative cases for the HMNFD /subscriptions API>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n        except AttributeError:\n            pass\n        try:\n>           item.runtest()\n\n/usr/lib/python3.9/site-packages/_pytest/runner.py:166: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <YamlItem Verify negative cases for the HMNFD /subscriptions API>\n\n    def runtest(self):\n        # Do a deep copy because this sometimes still retains things from previous tests(?)\n>       self.global_cfg = copy.deepcopy(load_global_cfg(self.config))\n\n/usr/lib/python3.9/site-packages/tavern/testutils/pytesthook/item.py:159: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npytest_config = <_pytest.config.Config object at 0x7f35323e23a0>\n\n    @lru_cache()\n    def load_global_cfg(pytest_config):\n        \"\"\"Load globally included config files from cmdline/cfg file arguments\n    \n        Args:\n            pytest_config (pytest.Config): Pytest config object\n    \n        Returns:\n            dict: variables/stages/etc from global config files\n    \n        Raises:\n            exceptions.UnexpectedKeysError: Invalid settings in one or more config\n                files detected\n        \"\"\"\n        # Load ini first\n        ini_global_cfg_paths = pytest_config.getini(\"tavern-global-cfg\") or []\n        # THEN load command line, to allow overwriting of values\n        cmdline_global_cfg_paths = pytest_config.getoption(\"tavern_global_cfg\") or []\n    \n        all_paths = ini_global_cfg_paths + cmdline_global_cfg_paths\n>       global_cfg = load_global_config(all_paths)\n\n/usr/lib/python3.9/site-packages/tavern/testutils/pytesthook/util.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nglobal_cfg_paths = ['src/app/tavern_global_config_ct_test_environment.yaml']\n\n    def load_global_config(global_cfg_paths):\n        \"\"\"Given a list of file paths to global config files, load each of them and\n        return the joined dictionary.\n    \n        This does a deep dict merge.\n    \n        Args:\n            global_cfg_paths (list(str)): List of filenames to load from\n    \n        Returns:\n            dict: joined global configs\n        \"\"\"\n        global_cfg = {}\n    \n        if global_cfg_paths:\n            logger.debug(\"Loading global config from %s\", global_cfg_paths)\n            for filename in global_cfg_paths:\n>               contents = load_single_document_yaml(filename)\n\n/usr/lib/python3.9/site-packages/tavern/util/general.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfilename = 'src/app/tavern_global_config_ct_test_environment.yaml'\n\n    def load_single_document_yaml(filename):\n        \"\"\"\n        Load a yaml file and expect only one document\n    \n        Args:\n            filename (str): path to document\n    \n        Returns:\n            dict: content of file\n    \n        Raises:\n            UnexpectedDocumentsError: If more than one document was in the file\n        \"\"\"\n    \n>       with open(filename, \"r\", encoding=\"utf-8\") as fileobj:\nE       FileNotFoundError: [Errno 2] No such file or directory: 'src/app/tavern_global_config_ct_test_environment.yaml'\n\n/usr/lib/python3.9/site-packages/tavern/util/loader.py:439: FileNotFoundError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"afterStages":[],"labels":[{"name":"parentSuite","value":"cray-hmnfd-hmth-test"},{"name":"suite","value":"non-disruptive"},{"name":"host","value":"4a354d75fb82"},{"name":"thread","value":"9-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"api.1-non-disruptive.test_subscriptions_negative.tavern"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"a37420d10efd5a06.json","parameterValues":[]}